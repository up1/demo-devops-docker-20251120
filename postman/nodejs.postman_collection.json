{
	"info": {
		"_postman_id": "3b74db88-cc2b-4e3e-8051-4dad5ea12692",
		"name": "nodejs",
		"schema": "https://schema.getpostman.com/json/collection/v2.0.0/collection.json",
		"_exporter_id": "1453931",
		"_collection_link": "https://red-firefly-245852.postman.co/workspace/devops-workshop~057045a7-1a0c-4314-8f2c-dcb8eb2e8d13/collection/1453931-3b74db88-cc2b-4e3e-8051-4dad5ea12692?action=share&source=collection_link&creator=1453931"
	},
	"item": [
		{
			"name": "Get-product-by-id-with-success",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"// Define your JSON schema here",
							"const schema = {",
							"    type: \"object\",",
							"    required: [\"id\", \"product_name\", \"product_desc\", \"price\", \"in_stock\"],",
							"    properties: {",
							"        id: {",
							"            type: \"number\",",
							"            description: \"Product ID\"",
							"        },",
							"        product_name: {",
							"            type: \"string\",",
							"            minLength: 1,",
							"            description: \"Product name\"",
							"        },",
							"        product_desc: {",
							"            type: \"string\",",
							"            description: \"Product description\"",
							"        },",
							"        price: {",
							"            type: \"string\",",
							"            pattern: \"^\\\\d+\\\\.\\\\d{2}$\",",
							"            description: \"Product price in decimal format\"",
							"        },",
							"        in_stock: {",
							"            type: \"number\",",
							"            enum: [0, 1],",
							"            description: \"Stock availability (0 or 1)\"",
							"        }",
							"    },",
							"    additionalProperties: false",
							"};",
							"",
							"// ============================================",
							"// VALIDATION ENGINE",
							"// ============================================",
							"",
							"class SchemaValidator {",
							"    constructor(schema) {",
							"        this.schema = schema;",
							"        this.errors = [];",
							"    }",
							"",
							"    validate(data, schema = this.schema, path = \"root\") {",
							"        this.errors = [];",
							"        this._validateNode(data, schema, path);",
							"        return {",
							"            valid: this.errors.length === 0,",
							"            errors: this.errors",
							"        };",
							"    }",
							"",
							"    _validateNode(data, schema, path) {",
							"        // Type validation",
							"        if (schema.type) {",
							"            if (!this._validateType(data, schema.type, path)) {",
							"                return;",
							"            }",
							"        }",
							"",
							"        // Enum validation",
							"        if (schema.enum && !schema.enum.includes(data)) {",
							"            this.errors.push({",
							"                path: path,",
							"                message: `Value must be one of: ${schema.enum.join(\", \")}`,",
							"                expected: schema.enum,",
							"                actual: data",
							"            });",
							"        }",
							"",
							"        // Type-specific validations",
							"        switch (schema.type) {",
							"            case \"object\":",
							"                this._validateObject(data, schema, path);",
							"                break;",
							"            case \"array\":",
							"                this._validateArray(data, schema, path);",
							"                break;",
							"            case \"string\":",
							"                this._validateString(data, schema, path);",
							"                break;",
							"            case \"number\":",
							"            case \"integer\":",
							"                this._validateNumber(data, schema, path);",
							"                break;",
							"        }",
							"    }",
							"",
							"    _validateType(data, expectedType, path) {",
							"        const actualType = this._getType(data);",
							"        ",
							"        if (expectedType === \"integer\" && actualType === \"number\") {",
							"            if (!Number.isInteger(data)) {",
							"                this.errors.push({",
							"                    path: path,",
							"                    message: \"Value must be an integer\",",
							"                    expected: \"integer\",",
							"                    actual: data",
							"                });",
							"                return false;",
							"            }",
							"            return true;",
							"        }",
							"",
							"        if (actualType !== expectedType) {",
							"            this.errors.push({",
							"                path: path,",
							"                message: `Type mismatch`,",
							"                expected: expectedType,",
							"                actual: actualType",
							"            });",
							"            return false;",
							"        }",
							"        return true;",
							"    }",
							"",
							"    _validateObject(data, schema, path) {",
							"        if (typeof data !== \"object\" || data === null || Array.isArray(data)) {",
							"            return;",
							"        }",
							"",
							"        // Required properties",
							"        if (schema.required) {",
							"            schema.required.forEach(prop => {",
							"                if (!(prop in data)) {",
							"                    this.errors.push({",
							"                        path: `${path}.${prop}`,",
							"                        message: `Required property is missing`,",
							"                        expected: `property \"${prop}\"`,",
							"                        actual: \"undefined\"",
							"                    });",
							"                }",
							"            });",
							"        }",
							"",
							"        // Validate properties",
							"        if (schema.properties) {",
							"            Object.keys(data).forEach(key => {",
							"                if (schema.properties[key]) {",
							"                    this._validateNode(data[key], schema.properties[key], `${path}.${key}`);",
							"                } else if (schema.additionalProperties === false) {",
							"                    this.errors.push({",
							"                        path: `${path}.${key}`,",
							"                        message: `Additional property not allowed`,",
							"                        expected: \"property not to exist\",",
							"                        actual: key",
							"                    });",
							"                }",
							"            });",
							"        }",
							"",
							"        // Min/Max properties",
							"        const propCount = Object.keys(data).length;",
							"        if (schema.minProperties && propCount < schema.minProperties) {",
							"            this.errors.push({",
							"                path: path,",
							"                message: `Object must have at least ${schema.minProperties} properties`,",
							"                expected: `>= ${schema.minProperties}`,",
							"                actual: propCount",
							"            });",
							"        }",
							"        if (schema.maxProperties && propCount > schema.maxProperties) {",
							"            this.errors.push({",
							"                path: path,",
							"                message: `Object must have at most ${schema.maxProperties} properties`,",
							"                expected: `<= ${schema.maxProperties}`,",
							"                actual: propCount",
							"            });",
							"        }",
							"    }",
							"",
							"    _validateArray(data, schema, path) {",
							"        if (!Array.isArray(data)) {",
							"            return;",
							"        }",
							"",
							"        // Length validations",
							"        if (schema.minItems && data.length < schema.minItems) {",
							"            this.errors.push({",
							"                path: path,",
							"                message: `Array must have at least ${schema.minItems} items`,",
							"                expected: `>= ${schema.minItems}`,",
							"                actual: data.length",
							"            });",
							"        }",
							"        if (schema.maxItems && data.length > schema.maxItems) {",
							"            this.errors.push({",
							"                path: path,",
							"                message: `Array must have at most ${schema.maxItems} items`,",
							"                expected: `<= ${schema.maxItems}`,",
							"                actual: data.length",
							"            });",
							"        }",
							"",
							"        // Unique items",
							"        if (schema.uniqueItems) {",
							"            const uniqueValues = new Set(data.map(item => JSON.stringify(item)));",
							"            if (uniqueValues.size !== data.length) {",
							"                this.errors.push({",
							"                    path: path,",
							"                    message: \"Array items must be unique\",",
							"                    expected: \"unique items\",",
							"                    actual: \"duplicate items found\"",
							"                });",
							"            }",
							"        }",
							"",
							"        // Validate items",
							"        if (schema.items) {",
							"            data.forEach((item, index) => {",
							"                this._validateNode(item, schema.items, `${path}[${index}]`);",
							"            });",
							"        }",
							"    }",
							"",
							"    _validateString(data, schema, path) {",
							"        if (typeof data !== \"string\") {",
							"            return;",
							"        }",
							"",
							"        // Length validations",
							"        if (schema.minLength !== undefined && data.length < schema.minLength) {",
							"            this.errors.push({",
							"                path: path,",
							"                message: `String length must be at least ${schema.minLength}`,",
							"                expected: `>= ${schema.minLength}`,",
							"                actual: data.length",
							"            });",
							"        }",
							"        if (schema.maxLength !== undefined && data.length > schema.maxLength) {",
							"            this.errors.push({",
							"                path: path,",
							"                message: `String length must be at most ${schema.maxLength}`,",
							"                expected: `<= ${schema.maxLength}`,",
							"                actual: data.length",
							"            });",
							"        }",
							"",
							"        // Pattern validation",
							"        if (schema.pattern) {",
							"            const regex = new RegExp(schema.pattern);",
							"            if (!regex.test(data)) {",
							"                this.errors.push({",
							"                    path: path,",
							"                    message: `String does not match pattern: ${schema.pattern}`,",
							"                    expected: `pattern: ${schema.pattern}`,",
							"                    actual: data",
							"                });",
							"            }",
							"        }",
							"",
							"        // Format validation (basic formats)",
							"        if (schema.format) {",
							"            this._validateFormat(data, schema.format, path);",
							"        }",
							"    }",
							"",
							"    _validateNumber(data, schema, path) {",
							"        if (typeof data !== \"number\") {",
							"            return;",
							"        }",
							"",
							"        // Range validations",
							"        if (schema.minimum !== undefined) {",
							"            if (schema.exclusiveMinimum && data <= schema.minimum) {",
							"                this.errors.push({",
							"                    path: path,",
							"                    message: `Number must be greater than ${schema.minimum}`,",
							"                    expected: `> ${schema.minimum}`,",
							"                    actual: data",
							"                });",
							"            } else if (!schema.exclusiveMinimum && data < schema.minimum) {",
							"                this.errors.push({",
							"                    path: path,",
							"                    message: `Number must be at least ${schema.minimum}`,",
							"                    expected: `>= ${schema.minimum}`,",
							"                    actual: data",
							"                });",
							"            }",
							"        }",
							"",
							"        if (schema.maximum !== undefined) {",
							"            if (schema.exclusiveMaximum && data >= schema.maximum) {",
							"                this.errors.push({",
							"                    path: path,",
							"                    message: `Number must be less than ${schema.maximum}`,",
							"                    expected: `< ${schema.maximum}`,",
							"                    actual: data",
							"                });",
							"            } else if (!schema.exclusiveMaximum && data > schema.maximum) {",
							"                this.errors.push({",
							"                    path: path,",
							"                    message: `Number must be at most ${schema.maximum}`,",
							"                    expected: `<= ${schema.maximum}`,",
							"                    actual: data",
							"                });",
							"            }",
							"        }",
							"",
							"        // Multiple of",
							"        if (schema.multipleOf && data % schema.multipleOf !== 0) {",
							"            this.errors.push({",
							"                path: path,",
							"                message: `Number must be a multiple of ${schema.multipleOf}`,",
							"                expected: `multiple of ${schema.multipleOf}`,",
							"                actual: data",
							"            });",
							"        }",
							"    }",
							"",
							"    _validateFormat(data, format, path) {",
							"        const formats = {",
							"            email: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,",
							"            uri: /^https?:\\/\\/.+/,",
							"            uuid: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,",
							"            date: /^\\d{4}-\\d{2}-\\d{2}$/,",
							"            \"date-time\": /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{3})?Z?$/,",
							"            ipv4: /^(\\d{1,3}\\.){3}\\d{1,3}$/,",
							"            ipv6: /^([0-9a-f]{0,4}:){7}[0-9a-f]{0,4}$/i",
							"        };",
							"",
							"        if (formats[format] && !formats[format].test(data)) {",
							"            this.errors.push({",
							"                path: path,",
							"                message: `String does not match format: ${format}`,",
							"                expected: format,",
							"                actual: data",
							"            });",
							"        }",
							"    }",
							"",
							"    _getType(value) {",
							"        if (value === null) return \"null\";",
							"        if (Array.isArray(value)) return \"array\";",
							"        return typeof value;",
							"    }",
							"}",
							"",
							"// ============================================",
							"// ERROR REPORTER",
							"// ============================================",
							"",
							"function generateErrorReport(errors) {",
							"    if (errors.length === 0) {",
							"        return \"âœ“ All validations passed\";",
							"    }",
							"",
							"    let report = `\\n${\"=\".repeat(50)}\\n`;",
							"    report += `SCHEMA VALIDATION FAILED - ${errors.length} error(s) found\\n`;",
							"    report += \"=\".repeat(50) + \"\\n\\n\";",
							"",
							"    errors.forEach((error, index) => {",
							"        report += `Error ${index + 1}:\\n`;",
							"        report += `  Path: ${error.path}\\n`;",
							"        report += `  Message: ${error.message}\\n`;",
							"        report += `  Expected: ${error.expected}\\n`;",
							"        report += `  Actual: ${error.actual}\\n\\n`;",
							"    });",
							"",
							"    return report;",
							"}",
							"",
							"// ============================================",
							"// MAIN VALIDATION EXECUTION",
							"// ============================================",
							"",
							"pm.test(\"Response status code is 200\", function () {",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"pm.test(\"Response is valid JSON\", function () {",
							"    pm.response.to.be.json;",
							"});",
							"",
							"pm.test(\"JSON Schema Validation\", function () {",
							"    let responseData;",
							"    ",
							"    try {",
							"        responseData = pm.response.json();",
							"    } catch (e) {",
							"        pm.expect.fail(\"Response is not valid JSON\");",
							"        return;",
							"    }",
							"",
							"    const validator = new SchemaValidator(schema);",
							"    const result = validator.validate(responseData);",
							"",
							"    // Log detailed report",
							"    console.log(generateErrorReport(result.errors));",
							"",
							"    // Store validation results in environment for debugging",
							"    pm.environment.set(\"last_validation_errors\", JSON.stringify(result.errors, null, 2));",
							"",
							"    // Assert validation passed",
							"    pm.expect(result.valid, generateErrorReport(result.errors)).to.be.true;",
							"});",
							"",
							"// ============================================",
							"// ADDITIONAL HELPFUL TESTS",
							"// ============================================",
							"",
							"pm.test(\"Response time is acceptable\", function () {",
							"    pm.expect(pm.response.responseTime).to.be.below(2000);",
							"});",
							"",
							"pm.test(\"Content-Type header is present\", function () {",
							"    pm.response.to.have.header(\"Content-Type\");",
							"});"
						],
						"type": "text/javascript",
						"packages": {},
						"requests": {}
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": "http://nodejs:3000/products/1"
			},
			"response": []
		},
		{
			"name": "Get-product-by-id-with-not-found",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 404\", function () {",
							"    pm.response.to.have.status(404);",
							"});",
							"",
							"pm.test(\"Check error message\", function () {",
							"    var jsonData = pm.response.json();",
							"    pm.expect(jsonData.message).to.eql('product id=4 not found in system');",
							"});"
						],
						"type": "text/javascript",
						"packages": {},
						"requests": {}
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": "http://nodejs:3000/products/4"
			},
			"response": []
		}
	]
}